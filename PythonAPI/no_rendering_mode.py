#!/usr/bin/env python

# Copyright (c) 2019 Computer Vision Center (CVC) at the Universitat Autonoma de
# Barcelona (UAB).
#
# This work is licensed under the terms of the MIT license.
# For a copy, see <https://opensource.org/licenses/MIT>.

# Allows visualising a 2D map generated by vehicles.

"""
Welcome to CARLA No Rendering Mode Visualizer
    I           : Toggle HUD
    H           : Hero Mode
    Mouse Wheel : Zoom In / Zoom Out
    Mouse Drag  : Move Map in Map Mode
    ESC         : quit
"""

# ==============================================================================
# -- find carla module ---------------------------------------------------------
# ==============================================================================

import glob
import os
import sys

try:
    sys.path.append(glob.glob('**/carla-*%d.%d-%s.egg' % (
        sys.version_info.major,
        sys.version_info.minor,
        'win-amd64' if os.name == 'nt' else 'linux-x86_64'))[0])
except IndexError:
    pass

# ==============================================================================
# -- imports -------------------------------------------------------------------
# ==============================================================================
import carla

import argparse
import logging
import datetime
import weakref
import math
import random

try:
    import pygame
    from pygame.locals import K_h
    from pygame.locals import K_i
    from pygame.locals import K_j
    from pygame.locals import K_w
    from pygame.locals import K_a
    from pygame.locals import K_s
    from pygame.locals import K_d
    from pygame.locals import K_q
    from pygame.locals import K_m
    from pygame.locals import K_p
    from pygame.locals import K_ESCAPE
    from pygame.locals import K_UP
    from pygame.locals import K_DOWN
    from pygame.locals import K_LEFT
    from pygame.locals import K_RIGHT
    from pygame.locals import K_SPACE
    from pygame.locals import K_COMMA
    from pygame.locals import K_PERIOD

except ImportError:
    raise RuntimeError('cannot import pygame, make sure pygame package is installed')

# ==============================================================================
# -- Constants -----------------------------------------------------------------
# ==============================================================================

# Colors

# We will use the color palette used in Tango Desktop Project (Each color is indexed depending on brightness level)
# See: https://en.wikipedia.org/wiki/Tango_Desktop_Project

COLOR_BUTTER_0 = pygame.Color(252, 233, 79)
COLOR_BUTTER_1 = pygame.Color(237, 212, 0)
COLOR_BUTTER_2 = pygame.Color(196, 160, 0)

COLOR_ORANGE_0 = pygame.Color(252, 175, 62)
COLOR_ORANGE_1 = pygame.Color(245, 121, 0)
COLOR_ORANGE_2 = pygame.Color(209, 92, 0)

COLOR_CHOCOLATE_0 = pygame.Color(233, 185, 110)
COLOR_CHOCOLATE_1 = pygame.Color(193, 125, 17)
COLOR_CHOCOLATE_2 = pygame.Color(143, 89, 2)

COLOR_CHAMELEON_0 = pygame.Color(138, 226, 52)
COLOR_CHAMELEON_1 = pygame.Color(115, 210, 22)
COLOR_CHAMELEON_2 = pygame.Color(78, 154, 6)

COLOR_SKY_BLUE_0 = pygame.Color(114, 159, 207)
COLOR_SKY_BLUE_1 = pygame.Color(52, 101, 164)
COLOR_SKY_BLUE_2 = pygame.Color(32, 74, 135)

COLOR_PLUM_0 = pygame.Color(173, 127, 168)
COLOR_PLUM_1 = pygame.Color(117, 80, 123)
COLOR_PLUM_2 = pygame.Color(92, 53, 102)

COLOR_SCARLET_RED_0 = pygame.Color(239, 41, 41)
COLOR_SCARLET_RED_1 = pygame.Color(204, 0, 0)
COLOR_SCARLET_RED_2 = pygame.Color(164, 0, 0)

COLOR_ALUMINIUM_0 = pygame.Color(238, 238, 236)
COLOR_ALUMINIUM_1 = pygame.Color(211, 215, 207)
COLOR_ALUMINIUM_2 = pygame.Color(186, 189, 182)
COLOR_ALUMINIUM_3 = pygame.Color(136, 138, 133)
COLOR_ALUMINIUM_4 = pygame.Color(85, 87, 83)
COLOR_ALUMINIUM_5 = pygame.Color(46, 52, 54)


COLOR_WHITE = pygame.Color(255, 255, 255)
COLOR_BLACK = pygame.Color(0, 0, 0)

# Legend names
LEGEND_NAME = 'LEGEND'
VEHICLE_NAME = 'Vehicle'
TRAFFIC_LIGHT_NAME = 'Traffic Light'
SPEED_LIMIT_NAME = 'Speed Limit'
WALKER_NAME = 'Walker'

# Module Defines
MODULE_WORLD = 'WORLD'
MODULE_HUD = 'HUD'
MODULE_INPUT = 'INPUT'
MODULE_RENDER = 'RENDER'

# Input
# Wheel used for zooming map
MIN_ZOOM = 1.0
MAX_ZOOM = 8.0

MAP_DEFAULT_ZOOM = 1.0
HERO_DEFAULT_ZOOM = 8.0

PIXELS_AHEAD_VEHICLE = 150
# ==============================================================================
# -- TransformHelper -----------------------------------------------------------
# ==============================================================================


class Util(object):
    @staticmethod
    def rotate_surface(img, pos, angle):
        w, h = img.get_size()
        img2 = pygame.Surface((w * 2, h * 2), pygame.SRCALPHA)
        img2.set_clip(pygame.Rect(w - pos[0], h - pos[1], w, h))
        img2.blit(img, (w - pos[0], h - pos[1]))
        rotated_surface = pygame.transform.rotate(img2, angle)
        return rotated_surface

    @staticmethod
    def normalize_vector(vector):
        length_vector = math.sqrt(vector[0] ** 2.0 + vector[1] ** 2.0)
        normalized_vector = (vector[0] / length_vector, vector[1] / length_vector)
        return normalized_vector

    @staticmethod
    def blits(destination_surface, source_surfaces, rect=None, blend_mode=0):
        for surface in source_surfaces:
            destination_surface.blit(surface[0], surface[1], rect, blend_mode)

    @staticmethod
    def distance_between_points(p1, p2):
        return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)


class TransformHelper(object):

    def __init__(self, min_map_point, max_map_point, map_size):
        self.min_map_point = min_map_point
        self.max_map_point = max_map_point
        self.map_size = map_size

        self.diff_min_max_map_point = (float((self.max_map_point[0] - self.min_map_point[0])),
                                       float((self.max_map_point[1] - self.min_map_point[1])))

    def convert_world_to_screen_size(self, size):
        screen_size = (int(size[0] / self.diff_min_max_map_point[0] * self.map_size),
                       int(size[1] / self.diff_min_max_map_point[1] * self.map_size))
        return (max(screen_size[0], 1), max(screen_size[1], 1))

    def convert_screen_to_world_size(self, size):
        world_size = (int(size[0] * self.diff_min_max_map_point[0] / self.map_size),
                      int(size[1] * self.diff_min_max_map_point[1] / self.map_size))
        return world_size

    def convert_world_to_screen_location(self, location):
        screen_point = (int(float(location.x - self.min_map_point[0]) / self.diff_min_max_map_point[0] * self.map_size),
                        int(float(location.y - self.min_map_point[1]) / self.diff_min_max_map_point[1] * self.map_size))
        return (max(screen_point[0], 1), max(screen_point[1], 1))

# ==============================================================================
# -- Vehicle ----------------------------------------------------------------------
# ==============================================================================


class Vehicle(object):

    def __init__(self, actor, color, map_transform_helper):
        self.actor = actor
        self.color = color
        self.map_transform_helper = map_transform_helper

        # Compute bounding box points
        self.bb_extent = self.actor.bounding_box.extent

        original_size = [self.bb_extent.x * 2.0, self.bb_extent.y * 2.0]

        self.surface_size = map_transform_helper.convert_world_to_screen_size(original_size)

        self.color = color

        surface = pygame.Surface((self.surface_size[0], self.surface_size[1]), pygame.SRCALPHA)
        surface.set_colorkey(COLOR_BLACK)

        pygame.draw.polygon(surface, color, [(0, 0), (self.surface_size[0], 0),
                                             (self.surface_size[0], self.surface_size[1]), (0, self.surface_size[1])])

        center = (self.surface_size[0] / 2, self.surface_size[1] / 2)
        arrow_tip = (self.surface_size[0], self.surface_size[1] / 2)
        arrow_half = self.surface_size[1] / 2 + arrow_tip[0] / 2

        line_0 = [center, arrow_tip]
        line_1 = [arrow_tip, (arrow_half, 0)]
        line_2 = [arrow_tip, (arrow_half, self.surface_size[1])]

        arrow_width = map_transform_helper.convert_world_to_screen_size((0.2, 0.2))[0]

        render_module = module_manager.get_module(MODULE_RENDER)
        render_module.draw_arrow(surface, COLOR_SKY_BLUE_0, [line_0, line_1, line_2], arrow_width)

        actor_location = self.actor.get_location()

        self.x, self.y = self.map_transform_helper.convert_world_to_screen_location(actor_location)

        self.surface = Util.rotate_surface(
            surface, (self.surface_size[0] / 2, self.surface_size[1] / 2), -self.actor.get_transform().rotation.yaw).convert()


class Walker(object):
    def __init__(self, actor, map_transform_helper):
        self.actor = actor

        actor_location = actor.get_location()
        self.x, self.y = map_transform_helper.convert_world_to_screen_location(actor_location)

        self.color = COLOR_ALUMINIUM_0

        # Compute bounding box points
        bb_extent = self.actor.bounding_box.extent
        original_size = [bb_extent.x * 2.0, bb_extent.y * 2.0]
        self.surface_size = map_transform_helper.convert_world_to_screen_size(original_size)

        self.surface = pygame.Surface((self.surface_size[0], self.surface_size[1]), pygame.SRCALPHA)
        self.surface.set_colorkey(COLOR_BLACK)

        pygame.draw.polygon(self.surface, self.color, [(0, 0), (self.surface_size[0], 0),
                                                       (self.surface_size[0], self.surface_size[1]), (0, self.surface_size[1])])


# ==============================================================================
# -- ModuleManager -------------------------------------------------------------
# ==============================================================================


class ModuleManager(object):
    def __init__(self):
        self.modules = []

    def register_module(self, module):
        self.modules.append(module)

    def clear_modules(self):
        del self.modules[:]

    def tick(self, clock):
        # Update all the modules
        for module in self.modules:
            module.tick(clock)

    def render(self, display):
        display.fill(COLOR_CHOCOLATE_0)
        for module in self.modules:
            module.render(display)

    def get_module(self, name):
        for module in self.modules:
            if module.name == name:
                return module

    def start_modules(self):
        for module in self.modules:
            module.start()


# ==============================================================================
# -- ModuleRender -------------------------------------------------------------
# ==============================================================================
class ModuleRender(object):
    def __init__(self, name):
        self.name = name

    def start(self):
        pass

    def render(self, display):
        pass

    def tick(self, clock):
        pass

    def draw_arrow(self, surface, color, lines, arrow_width):
        self.draw_line(surface, color, False, lines[0], arrow_width)
        self.draw_line(surface, color, False, lines[1], arrow_width)
        self.draw_line(surface, color, False, lines[2], arrow_width)

    def draw_line(self, surface, color, closed, line, width):
        pygame.draw.lines(surface, color, closed, line, width)

    def drawCircle(self, surface, x, y, radius, color):
        pygame.draw.circle(surface, color, (x, y), radius)

# ==============================================================================
# -- HUD -----------------------------------------------------------------------
# ==============================================================================


class Legend(object):
    def __init__(self, list_keys, header_font, font):
        self.header_surface = header_font.render(LEGEND_NAME, True, COLOR_ALUMINIUM_0)

        self.legend_surfaces = []
        self.surface_size = 25

        for key in list_keys:
            color_surface = pygame.Surface((self.surface_size, self.surface_size))
            color_surface.fill(key[0])

            font_surface = font.render(key[1], True, COLOR_ALUMINIUM_0)

            self.legend_surfaces.append((color_surface, font_surface))

    def render(self, display):

        h_offset = 20
        v_offset = 235
        h_space = 10

        display.blit(self.header_surface, (8 + 100 / 2, v_offset))

        for surface in self.legend_surfaces:
            v_offset = v_offset + surface[0].get_height() + 10
            display.blit(surface[0], (h_offset, v_offset))
            display.blit(surface[1], (surface[0].get_width() + h_offset + h_space, v_offset + 5))


class ModuleHUD (object):

    def __init__(self, name, width, height):
        self.name = name
        self._init_hud_params()
        self._init_data_params(width, height)

    def start(self):
        pass

    def _init_hud_params(self):
        fonts = [x for x in pygame.font.get_fonts() if 'mono' in x]
        default_font = 'ubuntumono'
        mono = default_font if default_font in fonts else fonts[0]
        mono = pygame.font.match_font(mono)
        self._font_mono = pygame.font.Font(mono, 14)
        self._header_font = pygame.font.SysFont('Arial', 14)

    def _init_data_params(self, height, width):
        self.dim = (height, width)
        self.show_info = True
        self._info_text = {}
        self.legend = Legend(((COLOR_PLUM_2, VEHICLE_NAME),
                              (COLOR_ALUMINIUM_0, WALKER_NAME)),
                             self._header_font,
                             self._font_mono)

    def tick(self, clock):
        pass

    def add_info(self, module_name, info):
        self._info_text[module_name] = info

    def render_actors_ids(self, vehicle_id_surface, list_actors, transform_helper, hero_actor):
        vehicle_id_surface.fill(COLOR_BLACK)
        if self.show_info:
            vehicle_id_surface.set_alpha(150)
            v_offset = 4
            for actor in list_actors:
                location = actor.get_location()
                location.y = location.y - v_offset
                x, y = transform_helper.convert_world_to_screen_location(location)

                angle = 0
                color_surface = pygame.Surface((len(str(actor.id)) * 8, 14))
                color_surface.fill(COLOR_BLACK)
                color_surface.set_alpha(200)

                rotated_color_surface = color_surface
                if hero_actor is not None:
                    angle = -hero_actor.get_transform().rotation.yaw - 90
                    rotated_color_surface = pygame.transform.rotate(color_surface, angle)

                vehicle_id_surface.blit(rotated_color_surface, (x, y))

                font_surface = self._header_font.render(str(actor.id), True, COLOR_WHITE)
                rotated_font_surface = pygame.transform.rotate(font_surface, angle).convert_alpha()
                vehicle_id_surface.blit(rotated_font_surface, (x, y))

        return vehicle_id_surface

    def render(self, display):
        if self.show_info:
            info_surface = pygame.Surface((240, self.dim[1]))
            info_surface.set_alpha(100)
            display.blit(info_surface, (0, 0))
            v_offset = 4
            bar_h_offset = 100
            bar_width = 106
            i = 0
            for module_name, module_info in self._info_text.items():
                surface = self._header_font.render(module_name, True, COLOR_ALUMINIUM_0).convert_alpha()
                display.blit(surface, (8 + bar_width / 2, 18 * i + v_offset))
                i += 1
                for item in module_info:
                    if v_offset + 18 > self.dim[1]:
                        break
                    if isinstance(item, list):
                        if len(item) > 1:
                            points = [(x + 8, v_offset + 8 + (1.0 - y) * 30) for x, y in enumerate(item)]
                            pygame.draw.lines(display, (255, 136, 0), False, points, 2)
                        item = None
                        v_offset += 18
                    elif isinstance(item, tuple):
                        if isinstance(item[1], bool):
                            rect = pygame.Rect((bar_h_offset, v_offset + 8), (6, 6))
                            pygame.draw.rect(display, COLOR_ALUMINIUM_0, rect, 0 if item[1] else 1)
                        else:
                            rect_border = pygame.Rect((bar_h_offset, v_offset + 8), (bar_width, 6))
                            pygame.draw.rect(display, COLOR_ALUMINIUM_0, rect_border, 1)
                            f = (item[1] - item[2]) / (item[3] - item[2])
                            if item[2] < 0.0:
                                rect = pygame.Rect((bar_h_offset + f * (bar_width - 6), v_offset + 8), (6, 6))
                            else:
                                rect = pygame.Rect((bar_h_offset, v_offset + 8), (f * bar_width, 6))
                            pygame.draw.rect(display, COLOR_ALUMINIUM_0, rect)
                        item = item[0]
                    if item:  # At this point has to be a str.
                        surface = self._font_mono.render(item, True, COLOR_ALUMINIUM_0).convert_alpha()
                        display.blit(surface, (8, 18 * i + v_offset))
                    v_offset += 18
            self.legend.render(display)

# ==============================================================================
# -- World ---------------------------------------------------------------------
# ==============================================================================


class ModuleWorld(object):

    def __init__(self, name, host, port, timeout, actor_filter):
        self.client = None
        self.name = name
        self.host = host
        self.port = port
        self.timeout = timeout
        self.actor_filter = actor_filter
        self.server_fps = 0.0
        self.simulation_time = 0

        self.server_clock = pygame.time.Clock()

        # World data
        self.world = None
        self.town_map = None
        self.actors = None

        # Store necessary modules
        self.hud_module = None
        self.module_input = None
        self.render_module = None

        self.surface_size = [0, 0]
        self.prev_scaled_size = 0
        self.scaled_size = 0

        # Hero actor
        self.hero_actor = None
        self.map_rendered = False
        self.accum_offset = [0, 0]
        self.scale_offset = [0, 0]

        self.map_surface = None
        self.vehicles_surface = None
        self.traffic_light_surface = None
        self.speed_limits_surface = None
        self.walkers_surface = None
        self.hero_actor_surface = None
        self.vehicle_id_surface = None
        self.result_surface = None

        self.waypoint_length = 1.5
        self.map_waypoints = None
        self.road_render_data_list = []
        self.intersection_render_data_list = []
        # Map Bounding box
        self.x_min = 0.0
        self.y_min = 0.0
        self.x_max = 0.0
        self.y_max = 0.0

        # Transform helper
        self.transform_helper = None

    def _get_data_from_carla(self, host, port, timeout):
        try:
            self.client = carla.Client(host, port)
            self.client.set_timeout(timeout)

            world = self.client.get_world()
            town_map = world.get_map()
            actors = world.get_actors()
            return (world, town_map, actors)

        except Exception as ex:
            logging.error(ex)
            exit_game()

    def _create_world_surfaces(self):
        self.map_surface = pygame.Surface((self.surface_size, self.surface_size)).convert()
        self.scaled_map_surface = pygame.Surface((self.surface_size, self.surface_size)).convert()

        self.vehicles_surface = pygame.Surface((self.surface_size, self.surface_size)).convert()
        self.vehicles_surface.set_colorkey(COLOR_BLACK)

        self.traffic_light_surface = pygame.Surface((self.surface_size, self.surface_size)).convert()
        self.traffic_light_surface.set_colorkey(COLOR_BLACK)

        self.speed_limits_surface = pygame.Surface((self.surface_size, self.surface_size)).convert()
        self.speed_limits_surface.set_colorkey(COLOR_BLACK)

        self.walkers_surface = pygame.Surface((self.surface_size, self.surface_size)).convert()
        self.walkers_surface.set_colorkey(COLOR_BLACK)

        self.hero_actor_surface = pygame.Surface((self.surface_size, self.surface_size)).convert()
        self.hero_actor_surface.set_colorkey(COLOR_BLACK)

        self.vehicle_id_surface = pygame.Surface((self.surface_size, self.surface_size)).convert()
        self.vehicle_id_surface.set_colorkey(COLOR_BLACK)

        self.result_surface = pygame.Surface((self.surface_size, self.surface_size)).convert()
        self.result_surface.set_colorkey(COLOR_BLACK)

    def _compute_map_bounding_box(self, map_waypoints):

        x_min = float('inf')
        y_min = float('inf')
        x_max = 0
        y_max = 0

        for waypoint in map_waypoints:
            x_max = max(x_max, waypoint.transform.location.x)
            x_min = min(x_min, waypoint.transform.location.x)

            y_max = max(y_max, waypoint.transform.location.y)
            y_min = min(y_min, waypoint.transform.location.y)

        return (x_min, y_min, x_max, y_max)

    def detect_line_type(self, town_map, road_id, lane_id, location):

        gen_wp = town_map.get_waypoint(location)

        is_central_line = False
        is_lateral_line = False
        if gen_wp is not None:
            is_central_line = (gen_wp.road_id == road_id and gen_wp.lane_id * lane_id < 0)
            is_lateral_line = (gen_wp.road_id == road_id and gen_wp.lane_id == lane_id)
        return is_central_line, is_lateral_line

    def prepare_waypoints_data(self):
        print("Generating map")

        # compute bounding boxes
        self.x_min, self.y_min, self.x_max, self.y_max = self._compute_map_bounding_box(self.map_waypoints)

        # Feed map bounding box and surface size to transform helper
        shrink_map_factor = 1.02
        self.transform_helper = TransformHelper(
            (self.x_min * shrink_map_factor, self.y_min * shrink_map_factor), (self.x_max * shrink_map_factor, self.y_max * shrink_map_factor), self.surface_size)

    def start(self):
        self.world, self.town_map, self.actors = self._get_data_from_carla(self.host, self.port, self.timeout)

        # Store necessary modules
        self.hud_module = module_manager.get_module(MODULE_HUD)
        self.module_input = module_manager.get_module(MODULE_INPUT)

        self.original_surface_size = min(self.hud_module.dim[0], self.hud_module.dim[1])
        self.surface_size = self.original_surface_size * MAX_ZOOM

        self.scaled_size = int(self.surface_size)
        self.prev_scaled_size = int(self.surface_size)

        self._create_world_surfaces()

        # Generate waypoints
        self.map_waypoints = self.town_map.generate_waypoints(self.waypoint_length)

        self.prepare_waypoints_data()

        # Module render
        self.render_module = module_manager.get_module(MODULE_RENDER)

        weak_self = weakref.ref(self)
        self.world.on_tick(lambda timestamp: ModuleWorld.on_world_tick(weak_self, timestamp))

    def select_hero_actor(self):
        hero_vehicles = [
            actor for actor in self.actors if 'vehicle' in actor.type_id and actor.attributes['role_name'] == 'hero']
        if len(hero_vehicles) > 0:
            self.hero_actor = random.choice(hero_vehicles)
        else:
            self._spawn_hero()

    def _spawn_hero(self):

        # Get a random blueprint.
        blueprint = random.choice(self.world.get_blueprint_library().filter(self.actor_filter))
        blueprint.set_attribute('role_name', 'hero')
        if blueprint.has_attribute('color'):
            color = random.choice(blueprint.get_attribute('color').recommended_values)
            blueprint.set_attribute('color', color)
        # Spawn the player.
        while self.hero_actor is None:
            spawn_points = self.world.get_map().get_spawn_points()
            spawn_point = random.choice(spawn_points) if spawn_points else carla.Transform()
            self.hero_actor = self.world.try_spawn_actor(blueprint, spawn_point)
    def tick(self, clock):
        self.update_hud_info(clock)

    def update_hud_info(self, clock):
        hero_mode_text = []
        if self.hero_actor is not None:
            vehicle_name, vehicle_brand, vehicle_model = self.hero_actor.type_id.split('.')
            type_id_text = vehicle_brand + ' ' + vehicle_model

            hero_speed = self.hero_actor.get_velocity()
            hero_speed_text = 3.6 * math.sqrt(hero_speed.x ** 2 + hero_speed.y ** 2 + hero_speed.z ** 2)

            state = self.hero_actor.get_traffic_light_state()
            affected_traffic_light = 'None'
            if state == carla.libcarla.TrafficLightState.Green:
                affected_traffic_light = 'GREEN'
            elif state == carla.libcarla.TrafficLightState.Yellow:
                affected_traffic_light = 'YELLOW'
            else:
                affected_traffic_light = 'RED'

            affected_speed_limit = self.hero_actor.get_speed_limit()

            hero_mode_text = [
                'Hero Mode:               ON',
                'Hero ID:               %4d' % self.hero_actor.id,
                'Hero Type ID:%12s' % type_id_text,
                'Hero speed:          %3d km/h' % hero_speed_text,
                'Hero Affected by:',
                '  Traffic Light:%12s' % affected_traffic_light,
                '  Speed Limit:       %3d km/h' % affected_speed_limit
            ]
        else:
            hero_mode_text = ['Hero Mode:               OFF']

        self.server_fps = self.server_clock.get_fps()
        module_info_text = [
            'Server:  % 16s FPS' % round(self.server_fps),
            'Client:  % 16s FPS' % round(clock.get_fps()),
            'Simulation time: % 12s' % datetime.timedelta(seconds=int(self.simulation_time)),
            'Map Name:          %10s' % self.world.map_name,
        ]

        module_info_text = module_info_text + hero_mode_text
        module_hud = module_manager.get_module(MODULE_HUD)
        module_hud.add_info(self.name, module_info_text)

    @staticmethod
    def on_world_tick(weak_self, timestamp):
        self = weak_self()
        if not self:
            return

        self.server_clock.tick()
        self.server_fps = self.server_clock.get_fps()
        self.simulation_time = timestamp.elapsed_seconds

        self.world = self.client.get_world()
        self.actors = self.world.get_actors()

    def render_map(self, map_surface):
        map_surface.fill(COLOR_ALUMINIUM_3)
        precision = 0.05

        def draw_lane_marking(surface, points, solid=True):
            if solid:
                pygame.draw.lines(surface, (252, 175, 62), False, points, 2)
            else:
                broken_lines = [x for n, x in enumerate(zip(*(iter(points),) * 20)) if n % 3 == 0]
                for line in broken_lines:
                    pygame.draw.lines(surface, (251, 241, 199), False, line, 2)

        def draw_arrow(surface, transform, color=(31, 31, 31)):
            transform.rotation.yaw += 180
            forward = transform.get_forward_vector()
            transform.rotation.yaw += 90
            right_dir = transform.get_forward_vector()
            start = transform.location
            end = start + 2.0 * forward
            right = start + 0.8 * forward + 0.4 * right_dir
            left = start + 0.8 * forward - 0.4 * right_dir
            pygame.draw.lines(surface, color, False, [self.transform_helper.convert_world_to_screen_location(x) for x in [start, end]], 4)
            pygame.draw.lines(surface, color, False, [self.transform_helper.convert_world_to_screen_location(x) for x in [left, start, right]], 4)

        def lateral_shift(transform, shift):
            transform.rotation.yaw += 90
            return transform.location + shift * transform.get_forward_vector()

        def does_cross_solid_line(waypoint, shift):
            w = self.town_map.get_waypoint(lateral_shift(waypoint.transform, shift), project_to_road=False)
            if w is None or w.road_id != waypoint.road_id:
                return True
            else:
                return (w.lane_id * waypoint.lane_id < 0) or w.lane_id == waypoint.lane_id

        topology = [x[0] for x in self.town_map.get_topology()]
        topology = sorted(topology, key=lambda w: w.transform.location.z)

        for waypoint in topology:
            waypoints = [waypoint]
            nxt = waypoint.next(precision)[0]
            while nxt.road_id == waypoint.road_id:
                waypoints.append(nxt)
                nxt = nxt.next(precision)[0]

            left_marking = [lateral_shift(w.transform, -w.lane_width * 0.5) for w in waypoints]
            right_marking = [lateral_shift(w.transform, w.lane_width * 0.5) for w in waypoints]

            polygon = left_marking + [x for x in reversed(right_marking)]
            polygon = [self.transform_helper.convert_world_to_screen_location(x) for x in polygon]

            pygame.draw.polygon(map_surface, (38,38,38), polygon, 10)
            pygame.draw.polygon(map_surface, (38,38,38), polygon)
        
            if not waypoint.is_intersection:
                sample = waypoints[len(waypoints)/2]
                draw_lane_marking(
                    map_surface,
                    [self.transform_helper.convert_world_to_screen_location(x) for x in left_marking],
                    does_cross_solid_line(sample, -sample.lane_width * 1.1))
                draw_lane_marking(
                    map_surface,
                    [self.transform_helper.convert_world_to_screen_location(x) for x in right_marking],
                    does_cross_solid_line(sample, sample.lane_width * 1.1))
                for n, wp in enumerate(waypoints):
                    if (n % 400) == 0:
                        draw_arrow(map_surface, wp.transform)

    def _split_actors(self, actors):
        vehicles = []
        traffic_lights = []
        speed_limits = []
        walkers = []

        for actor in actors:
            if 'vehicle' in actor.type_id:
                vehicles.append(actor)
            elif 'traffic_light' in actor.type_id:
                traffic_lights.append(actor)
            elif 'speed_limit' in actor.type_id:
                speed_limits.append(actor)
            elif 'walker' in actor.type_id:
                walkers.append(actor)

        return (vehicles, traffic_lights, speed_limits, walkers)


    def _render_traffic_lights(self, surface, list_tl, transform_helper):
        
        for tl in list_tl:
            color = COLOR_BLACK
            if tl.state == carla.libcarla.TrafficLightState.Green:
                color = COLOR_CHAMELEON_1
            elif tl.state == carla.libcarla.TrafficLightState.Yellow:
                color = COLOR_BUTTER_1
            else:
                color = COLOR_SCARLET_RED_1

            # Compute bounding box points
            # bb_extent = self.actor.bounding_box.extent
            bb_x = 1
            bb_y = 1
            corners = [
                carla.Location(x=-bb_x, y=-bb_y),
                carla.Location(x=bb_x, y=-bb_y),
                carla.Location(x=bb_x, y=bb_y),
                carla.Location(x=-bb_x, y=bb_y)]
            
            t = tl.get_transform()
            t.transform(corners)
            
            corners = [transform_helper.convert_world_to_screen_location(p) for p in corners]
            pygame.draw.polygon(surface, color, corners)


    def _render_speed_limits(self, surface, list_sl, transform_helper):
        
        font_size = 10    
        radius = 10
        font = pygame.font.SysFont('Arial', font_size)

        for sl in list_sl:
            
            x, y = transform_helper.convert_world_to_screen_location(sl.get_location())

            # Render speed limit
            white_circle_radius = int(radius * 0.75)

            pygame.draw.circle(surface, COLOR_SCARLET_RED_0, (x, y), radius)
            pygame.draw.circle(surface, COLOR_ALUMINIUM_0, (x, y), white_circle_radius)
            
            limit = sl.type_id.split('.')[2]
            font_surface = font.render(limit, False, COLOR_ALUMINIUM_5)

            # Blit
            if self.hero_actor is not None:
                # Rotate font surface with respect to hero vehicle front
                angle = -self.hero_actor.get_transform().rotation.yaw - 90.0
                font_surface = Util.rotate_surface(font_surface, (radius / 2, radius / 2), angle)
                offset = font_surface.get_rect(center=(x, y))
                surface.blit(font_surface, offset)

            else:
                surface.blit(font_surface, (x - radius/2,y - radius/2))
        
    def render_actors(self, vehicles, traffic_lights, speed_limits, walkers):
        # Render Vehicles
        vehicle_renderer = []
        for actor in vehicles:
            vehicle = Vehicle(actor, COLOR_PLUM_1, self.transform_helper)
            vehicle_renderer.append(
                (vehicle.surface, (vehicle.x - vehicle.surface.get_width() / 2, vehicle.y - vehicle.surface.get_height() / 2)))

        Util.blits(self.vehicles_surface, vehicle_renderer, None, pygame.BLEND_RGB_MAX)

        # Render Traffic Lights
        self._render_traffic_lights(self.traffic_light_surface, traffic_lights, self.transform_helper)
        
        # Render Speed limit
        self._render_speed_limits(self.speed_limits_surface, speed_limits, self.transform_helper)

        # Render Walkers
        walkers_renderer = []
        for actor in walkers:
            walker = Walker(actor, self.transform_helper)
            walkers_renderer.append((walker.surface, (walker.x, walker.y)))
        Util.blits(self.walkers_surface, walkers_renderer)

    def clip_surfaces(self, clipping_rect):
        self.map_surface.set_clip(clipping_rect)
        self.vehicles_surface.set_clip(clipping_rect)
        self.traffic_light_surface.set_clip(clipping_rect)
        self.speed_limits_surface.set_clip(clipping_rect)
        self.walkers_surface.set_clip(clipping_rect)
        self.vehicle_id_surface.set_clip(clipping_rect)
        self.hero_actor_surface.set_clip(clipping_rect)
        self.result_surface.set_clip(clipping_rect)

    def render(self, display):
        if not self.map_rendered:
            self.render_map(self.map_surface)

            self.scaled_map_surface = pygame.transform.smoothscale(
                self.map_surface, (self.scaled_size, self.scaled_size))
            self.map_rendered = True

        self.vehicles_surface.fill(COLOR_BLACK)
        self.traffic_light_surface.fill(COLOR_BLACK)
        self.speed_limits_surface.fill(COLOR_BLACK)
        self.walkers_surface.fill(COLOR_BLACK)
        self.hero_actor_surface.fill(COLOR_BLACK)
        self.result_surface.fill(COLOR_BLACK)

        vehicles, traffic_lights, speed_limits, walkers = self._split_actors(self.actors)

        scale_factor = self.module_input.wheel_offset / MAX_ZOOM
        self.scaled_size = int(self.surface_size * scale_factor)

        if self.scaled_size != self.prev_scaled_size:
            m = self.module_input.mouse_pos

            # Percentage of surface where mouse position is actually
            px = (m[0] - self.accum_offset[0]) / float(self.prev_scaled_size)
            py = (m[1] - self.accum_offset[1]) / float(self.prev_scaled_size)

            # Offset will be the previously accumulated offset added with the
            # difference of mouse positions in the old and new scales
            diff_between_scales = ((float(self.prev_scaled_size) * px) - (float(self.scaled_size) * px),
                                   (float(self.prev_scaled_size) * py) - (float(self.scaled_size) * py))

            self.scale_offset = (self.accum_offset[0] + diff_between_scales[0],
                                 self.accum_offset[1] + diff_between_scales[1])

            # Accumulate offset
            self.accum_offset = (self.accum_offset[0] + diff_between_scales[0],
                                 self.accum_offset[1] + diff_between_scales[1])

            # Update previous scale
            self.prev_scaled_size = self.scaled_size

            # Scale performed
            self.transform_helper.map_size = self.scaled_size
            self.scaled_map_surface = pygame.transform.smoothscale(
                self.map_surface, (self.scaled_size, self.scaled_size))

        # Render Vehicles
        self.render_actors(vehicles, traffic_lights, speed_limits, walkers)



        # Blit surfaces

        surfaces = ((self.scaled_map_surface, (0, 0)),
                    (self.vehicles_surface, (0, 0)),
                    (self.traffic_light_surface, (0, 0)),
                    (self.speed_limits_surface, (0, 0)),
                    (self.walkers_surface, (0, 0)),
                    (self.vehicle_id_surface, (0, 0)),
                    (self.hero_actor_surface, (0, 0))
                    )
        self.hud_module.render_actors_ids(self.vehicle_id_surface, vehicles,
                                          self.transform_helper, self.hero_actor)

        rotated_result_surface = self.result_surface
        
        angle = 0
        center_offset = (0, 0)
        if self.hero_actor is not None:
            # Translation offset
            hero_front = self.hero_actor.get_transform().get_forward_vector()

            hero_location_screen = self.transform_helper.convert_world_to_screen_location(self.hero_actor.get_location())

            translation_offset = (-hero_location_screen[0] - hero_front.x * PIXELS_AHEAD_VEHICLE,
                                  (-hero_location_screen[1] - hero_front.y * PIXELS_AHEAD_VEHICLE))
            selected_hero_actor = [vehicle for vehicle in vehicles if vehicle.id == self.hero_actor.id]
            if len(selected_hero_actor) != 0:
                angle = self.hero_actor.get_transform().rotation.yaw + 90.0
                center_offset = (display.get_width() / 2, display.get_height() / 2)

            hero_surface = pygame.Surface((self.original_surface_size, self.original_surface_size), pygame.SRCALPHA)
            # Apply clipping rect
            clipping_rect = pygame.Rect(-translation_offset[0] - hero_surface.get_width() / 2,
                                        -translation_offset[1] - hero_surface.get_height() / 2, self.hud_module.dim[0], self.hud_module.dim[1])
            self.clip_surfaces(clipping_rect)
            Util.blits(self.result_surface, surfaces)

            hero_surface.fill(COLOR_CHOCOLATE_1)
            hero_surface.blit(self.result_surface, (translation_offset[0] + hero_surface.get_width() / 2,
                                                    translation_offset[1] + hero_surface.get_height() / 2))

            rotated_result_surface = Util.rotate_surface(hero_surface,
                                                         (hero_surface.get_width() / 2, hero_surface.get_height() / 2),
                                                         angle)

            round_surface = pygame.Surface((display.get_width(), display.get_height()), pygame.SRCALPHA)
            round_surface.fill(COLOR_BLACK)

            self.render_module.drawCircle(
                round_surface, center_offset[0], center_offset[1], display.get_height()/2, COLOR_WHITE)

            final_offset = rotated_result_surface.get_rect(center=center_offset)
            round_surface.blit(rotated_result_surface, final_offset, None, pygame.BLEND_MULT)
            display.blit(round_surface, (0, 0))
        else:
            # Translation offset
            translation_offset = ((self.module_input.mouse_offset[0]) * scale_factor + self.scale_offset[0],
                                  self.module_input.mouse_offset[1] * scale_factor + self.scale_offset[1])
            center_offset = ((display.get_width() * MAX_ZOOM - self.surface_size) / 2 * scale_factor, 0)
            
            # Apply clipping rect
            clipping_rect = pygame.Rect(-translation_offset[0] - center_offset[0], -translation_offset[1],
                                        self.hud_module.dim[0], self.hud_module.dim[1])
            self.clip_surfaces(clipping_rect)
            Util.blits(self.result_surface, surfaces)

            display.blit(rotated_result_surface, (translation_offset[0] + center_offset[0],
                                                  translation_offset[1]))


# ==============================================================================
# -- Input -----------------------------------------------------------
# ==============================================================================


class ModuleInput(object):
    def __init__(self, name):
        self.name = name
        self.mouse_pos = (0, 0)
        self.mouse_offset = [0.0, 0.0]
        self.wheel_offset = 1.0
        self.wheel_amount = 0.1
        self._steer_cache = 0.0

        self._control = None
        self._autopilot_enabled = True

    def start(self):
        pass

    def render(self, display):
        pass

    def tick(self, clock):
        self.parse_input(clock)

    def _parse_events(self):
        self.mouse_pos = pygame.mouse.get_pos()
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                exit_game()
            elif event.type == pygame.KEYUP:
                if event.key == K_ESCAPE:
                    exit_game()
                if event.key == K_h:
                    module_world = module_manager.get_module(MODULE_WORLD)
                    if module_world.hero_actor is None:
                        module_world.select_hero_actor()
                        self.wheel_offset = HERO_DEFAULT_ZOOM
                        self._control = carla.VehicleControl()
                        self._autopilot_enabled = False
                    else:
                        self.wheel_offset = MAP_DEFAULT_ZOOM
                        self.mouse_offset = [0, 0]

                        module_world.hero_actor = None
                        
                if event.key == K_i:
                    module_hud = module_manager.get_module(MODULE_HUD)
                    module_hud.show_info = not module_hud.show_info                    

                if isinstance(self._control, carla.VehicleControl):
                    if event.key == K_q:
                        self._control.gear = 1 if self._control.reverse else -1
                    elif event.key == K_m:
                        self._control.manual_gear_shift = not self._control.manual_gear_shift
                        self._control.gear = world.player.get_control().gear
                    elif self._control.manual_gear_shift and event.key == K_COMMA:
                        self._control.gear = max(-1, self._control.gear - 1)
                    elif self._control.manual_gear_shift and event.key == K_PERIOD:
                        self._control.gear = self._control.gear + 1
                    elif event.key == K_p:
                        self._autopilot_enabled = not self._autopilot_enabled
                        world = module_manager.get_module(MODULE_WORLD)
                        world.hero_actor.set_autopilot(self._autopilot_enabled)

            elif event.type == pygame.MOUSEBUTTONDOWN:
                if event.button == 4:
                    self.wheel_offset += self.wheel_amount
                    if self.wheel_offset >= MAX_ZOOM:
                        self.wheel_offset = MAX_ZOOM

                if event.button == 5:
                    self.wheel_offset -= self.wheel_amount
                    if self.wheel_offset <= MIN_ZOOM:
                        self.wheel_offset = MIN_ZOOM

    def _parse_keys(self, milliseconds):
        keys = pygame.key.get_pressed()
        self._control.throttle = 1.0 if keys[K_UP] or keys[K_w] else 0.0
        steer_increment = 5e-4 * milliseconds
        if keys[K_LEFT] or keys[K_a]:
            self._steer_cache -= steer_increment
        elif keys[K_RIGHT] or keys[K_d]:
            self._steer_cache += steer_increment
        else:
            self._steer_cache = 0.0
        self._steer_cache = min(0.7, max(-0.7, self._steer_cache))
        self._control.steer = round(self._steer_cache, 1)
        self._control.brake = 1.0 if keys[K_DOWN] or keys[K_s] else 0.0
        self._control.hand_brake = keys[K_SPACE]

    def _parse_mouse(self):
        if pygame.mouse.get_pressed()[0]:
            x, y = pygame.mouse.get_pos()
            self.mouse_offset[0] += x - self.mouse_pos[0]
            self.mouse_offset[1] += y - self.mouse_pos[1]
            self.mouse_pos = (x, y)

    def parse_input(self, clock):
        self._parse_events()
        self._parse_mouse()
        if not self._autopilot_enabled:
            if isinstance(self._control, carla.VehicleControl):
                self._parse_keys(clock.get_time())
                self._control.reverse = self._control.gear < 0
            world = module_manager.get_module(MODULE_WORLD)
            if (world.hero_actor is not None):
                world.hero_actor.apply_control(self._control)


# ==============================================================================
# -- Global Objects ------------------------------------------------------------
# ==============================================================================
module_manager = ModuleManager()


# ==============================================================================
# -- Game Loop ---------------------------------------------------------------
# ==============================================================================


def game_loop(args):
    # Init Pygame
    pygame.init()
    display = pygame.display.set_mode(
        (args.width, args.height),
        pygame.HWSURFACE | pygame.DOUBLEBUF)
    pygame.display.set_caption(args.description)

    # Init modules
    input_module = ModuleInput(MODULE_INPUT)
    hud_module = ModuleHUD(MODULE_HUD, args.width, args.height)
    world_module = ModuleWorld(MODULE_WORLD, args.host, args.port, 2.0, args.filter)
    render_module = ModuleRender(MODULE_RENDER)

    # Register Modules
    module_manager.register_module(input_module)
    module_manager.register_module(render_module)
    module_manager.register_module(world_module)
    module_manager.register_module(hud_module)

    module_manager.start_modules()

    clock = pygame.time.Clock()
    while True:
        clock.tick_busy_loop(60)

        module_manager.tick(clock)
        module_manager.render(display)

        pygame.display.flip()


def exit_game():
    module_manager.clear_modules()
    pygame.quit()
    sys.exit()

# ==============================================================================
# -- Main --------------------------------------------------------------------
# ==============================================================================


def main():
    # Parse arguments
    argparser = argparse.ArgumentParser(
        description='CARLA No Rendering Mode Visualizer')
    argparser.add_argument(
        '-v', '--verbose',
        action='store_true',
        dest='debug',
        help='print debug information')
    argparser.add_argument(
        '--host',
        metavar='H',
        default='127.0.0.1',
        help='IP of the host server (default: 127.0.0.1)'
    )
    argparser.add_argument(
        '-p', '--port',
        metavar='P',
        default=2000,
        type=int,
        help='TCP port to listen to (default: 2000)')
    argparser.add_argument(
        '--res',
        metavar='WIDTHxHEIGHT',
        default='1280x720',
        help='window resolution (default: 1280x720)')
    argparser.add_argument(
        '--filter',
        metavar='PATTERN',
        default='vehicle.*',
        help='actor filter (default: "vehicle.*")')

    args = argparser.parse_args()
    args.description = argparser.description
    args.width, args.height = [int(x) for x in args.res.split('x')]

    log_level = logging.DEBUG if args.debug else logging.INFO
    logging.basicConfig(format='%(levelname)s: %(message)s', level=log_level)

    logging.info('listening to server %s:%s', args.host, args.port)
    print(__doc__)

    try:
        game_loop(args)
    except KeyboardInterrupt:
        print('\nCancelled by user. Bye!')


if __name__ == '__main__':
    main()
