#!/usr/bin/env python

# Copyright (c) 2017 Computer Vision Center (CVC) at the Universitat Autonoma de
# Barcelona (UAB).
#
# This work is licensed under the terms of the MIT license.
# For a copy, see <https://opensource.org/licenses/MIT>.

# Allows visualising a 2D map generated by vehicles.

"""
Welcome to CARLA No Rendering Mode Visualizer

    ESC         : quit
"""

# ==============================================================================
# -- find carla module ---------------------------------------------------------
# ==============================================================================

import glob
import os
import sys

try:
    sys.path.append(glob.glob('**/carla-*%d.%d-%s.egg' % (
        sys.version_info.major,
        sys.version_info.minor,
        'win-amd64' if os.name == 'nt' else 'linux-x86_64'))[0])
except IndexError:
    pass

# ==============================================================================
# -- imports -------------------------------------------------------------------
# ==============================================================================
import carla

import argparse
import logging

try:
    import pygame
    from pygame.locals import K_DOWN
    from pygame.locals import K_LEFT
    from pygame.locals import K_RIGHT
    from pygame.locals import K_UP
    from pygame.locals import K_ESCAPE
except ImportError:
    raise RuntimeError('cannot import pygame, make sure pygame package is installed')

# ==============================================================================
# -- ModuleManager -------------------------------------------------------------
# ==============================================================================


class Module(object):
    def __init__(self, name):
        self.module_name = name

    def tick(self, clock):
        raise NotImplementedError("Please implement this method")

    def render(self, display):
        raise NotImplementedError("Please implement this method")


class ModuleManager(object):
    def __init__(self):
        self.modules = []

    def register_module(self, module):
        self.modules.append(module)

    def tick(self, clock):
        # Update all the modules
        for module in self.modules:
            module.tick(clock)

    def render(self, display):
        display.fill((0, 0, 0))
        for module in self.modules:
            module.render(display)

# ==============================================================================
# -- HUD -----------------------------------------------------------------------
# ==============================================================================


class HUD (Module):

    def __init__(self, name, width, height, on_world_tick):
        Module.__init__(self, name)
        self._init_data_params(width, height)
        self._init_hud_params()
        on_world_tick(self.on_world_tick)

    def _init_hud_params(self):
        font = pygame.font.Font(pygame.font.get_default_font(), 20)
        fonts = [x for x in pygame.font.get_fonts() if 'mono' in x]
        default_font = 'ubuntumono'
        mono = default_font if default_font in fonts else fonts[0]
        mono = pygame.font.match_font(mono)
        self._font_mono = pygame.font.Font(mono, 14)

    def _init_data_params(self, height, width):
        self.dim = (height, width)
        self.server_fps = 0
        self.frame_number = 0
        self.simulation_time = 0
        self._show_info = True
        self._info_text = []
        self._server_clock = pygame.time.Clock()

    def on_world_tick(self, timestamp):
        self._server_clock.tick()
        self.server_fps = self._server_clock.get_fps()

    def tick(self, clock):
        if not self._show_info:
            return
        self._info_text = [
            'Server:  % 16d FPS' % self.server_fps,
            'Client:  % 16d FPS' % clock.get_fps()
        ]

    def render(self, display):
        if self._show_info:
            info_surface = pygame.Surface((220, self.dim[1]))
            info_surface.set_alpha(100)
            display.blit(info_surface, (0, 0))
            v_offset = 4
            bar_h_offset = 100
            bar_width = 106
            for item in self._info_text:
                if v_offset + 18 > self.dim[1]:
                    break
                if isinstance(item, list):
                    if len(item) > 1:
                        points = [(x + 8, v_offset + 8 + (1.0 - y) * 30) for x, y in enumerate(item)]
                        pygame.draw.lines(display, (255, 136, 0), False, points, 2)
                    item = None
                    v_offset += 18
                elif isinstance(item, tuple):
                    if isinstance(item[1], bool):
                        rect = pygame.Rect((bar_h_offset, v_offset + 8), (6, 6))
                        pygame.draw.rect(display, (255, 255, 255), rect, 0 if item[1] else 1)
                    else:
                        rect_border = pygame.Rect((bar_h_offset, v_offset + 8), (bar_width, 6))
                        pygame.draw.rect(display, (255, 255, 255), rect_border, 1)
                        f = (item[1] - item[2]) / (item[3] - item[2])
                        if item[2] < 0.0:
                            rect = pygame.Rect((bar_h_offset + f * (bar_width - 6), v_offset + 8), (6, 6))
                        else:
                            rect = pygame.Rect((bar_h_offset, v_offset + 8), (f * bar_width, 6))
                        pygame.draw.rect(display, (255, 255, 255), rect)
                    item = item[0]
                if item:  # At this point has to be a str.
                    surface = self._font_mono.render(item, True, (255, 255, 255))
                    display.blit(surface, (8, v_offset))
                v_offset += 18

# ==============================================================================
# -- World ---------------------------------------------------------------------
# ==============================================================================


class World(Module):
    def __init__(self, name, host, port, timeout):
        Module.__init__(self, name)

        try:
            client = carla.Client(host, port)
            client.set_timeout(timeout)
            self.world = client.get_world()

        except Exception as ex:
            logging.error('Failed connecting to CARLA server')
            exit_game()

    def tick(self, clock):
        pass
        # self.hud.tick(clock)

    def render(self, display):
        actors = self.world.get_actors()

        # Filter actors to obtain vehicle and traffic light
        vehicles = [actor for actor in actors if 'vehicle' in actor.type_id]
        traffic_lights = [actor for actor in actors if 'traffic_light' in actor.type_id]
        radius = 2
        width = 1
        for vehicle in vehicles:
            vehicle_location = vehicle.get_location()

            pygame.draw.circle(display, (255, 0, 0), (int(500 + vehicle_location.x),
                                                      500 + int(vehicle_location.y)), radius, width)

        for traffic in traffic_lights:
            traffic_location = traffic.get_location()

            pygame.draw.circle(display, (0, 255, 0), (int(traffic_location.x),
                                                      int(traffic_location.y)), radius, width)
# ==============================================================================
# -- KeyboardInput -----------------------------------------------------------
# ==============================================================================


class Input(Module):
    def render(self, display):
        pass

    def tick(self, clock):
        self.parse_input()

    def _parse_events(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            elif event.type == pygame.KEYUP:
                # Quick actions
                if event.key == K_ESCAPE:
                    exit_game()

    def _parse_keys(self):
        keys = pygame.key.get_pressed()
        # if keys[pygame.K_LEFT]:
        # Do something

    def parse_input(self):
        self._parse_events()
        self._parse_keys()

# ==============================================================================
# -- game_loop() ---------------------------------------------------------------
# ==============================================================================


def game_loop(args):
    # Init Pygame
    pygame.init()
    display = pygame.display.set_mode(
        (args.width, args.height),
        pygame.HWSURFACE | pygame.DOUBLEBUF)
    pygame.display.set_caption(args.description)

    # Init modules
    module_manager = ModuleManager()

    input_module = Input("Input")
    world_module = World("World", args.host, args.port, 2.0)
    hud_module = HUD("HUD", args.width, args.height, world_module.world.on_tick)

    # Register Modules
    module_manager.register_module(input_module)
    module_manager.register_module(hud_module)
    module_manager.register_module(world_module)

    clock = pygame.time.Clock()
    while True:
        clock.tick_busy_loop(60)

        module_manager.tick(clock)
        module_manager.render(display)

        pygame.display.flip()


def exit_game():
    pygame.quit()
    sys.exit()

# ==============================================================================
# -- main() --------------------------------------------------------------------
# ==============================================================================


def main():
    # Parse arguments
    argparser = argparse.ArgumentParser(
        description='CARLA No Rendering Mode Visualizer')
    argparser.add_argument(
        '-v', '--verbose',
        action='store_true',
        dest='debug',
        help='print debug information')
    argparser.add_argument(
        '--host',
        metavar='H',
        default='127.0.0.1',
        help='IP of the host server (default: 127.0.0.1)'
    )
    argparser.add_argument(
        '-p', '--port',
        metavar='P',
        default=2000,
        type=int,
        help='TCP port to listen to (default: 2000)')
    argparser.add_argument(
        '--res',
        metavar='WIDTHxHEIGHT',
        default='1280x720',
        help='window resolution (default: 1280x720)')

    args = argparser.parse_args()
    args.description = argparser.description
    args.width, args.height = [int(x) for x in args.res.split('x')]

    log_level = logging.DEBUG if args.debug else logging.INFO
    logging.basicConfig(format='%(levelname)s: %(message)s', level=log_level)

    logging.info('listening to server %s:%s', args.host, args.port)
    print(__doc__)

    # Call game_loop
    try:
        game_loop(args)
    except KeyboardInterrupt:
        print('\nCancelled by user. Bye!')


if __name__ == '__main__':
    main()
