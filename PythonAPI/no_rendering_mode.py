#!/usr/bin/env python

# Copyright (c) 2017 Computer Vision Center (CVC) at the Universitat Autonoma de
# Barcelona (UAB).
#
# This work is licensed under the terms of the MIT license.
# For a copy, see <https://opensource.org/licenses/MIT>.

# Allows visualising a 2D map generated by vehicles.

"""
Welcome to CARLA No Rendering Mode Visualizer

    ESC         : quit
"""

# ==============================================================================
# -- find carla module ---------------------------------------------------------
# ==============================================================================

import glob
import os
import sys

try:
    sys.path.append(glob.glob('**/carla-*%d.%d-%s.egg' % (
        sys.version_info.major,
        sys.version_info.minor,
        'win-amd64' if os.name == 'nt' else 'linux-x86_64'))[0])
except IndexError:
    pass

# ==============================================================================
# -- imports -------------------------------------------------------------------
# ==============================================================================
import carla

import argparse
import logging
import weakref
import math

try:
    import pygame
    from pygame import gfxdraw
    from pygame.locals import K_a
    from pygame.locals import K_h
    from pygame.locals import K_DOWN
    from pygame.locals import K_LEFT
    from pygame.locals import K_RIGHT
    from pygame.locals import K_UP
    from pygame.locals import K_ESCAPE
except ImportError:
    raise RuntimeError('cannot import pygame, make sure pygame package is installed')


# ==============================================================================
# -- Constants -------------------------------------------------------------
# ==============================================================================

COLOR_RED = pygame.Color(255, 0, 0)
COLOR_BLUE = pygame.Color(0, 0, 255)
COLOR_GREEN = pygame.Color(0, 255, 0)
COLOR_YELLOW = pygame.Color(255, 255, 0)
COLOR_MAGENTA = pygame.Color(255, 0, 255)
COLOR_CYAN = pygame.Color(0, 255, 255)
COLOR_WHITE = pygame.Color(255, 255, 255)
COLOR_BLACK = pygame.Color(0, 0, 0)
COLOR_GREY = pygame.Color(127, 127, 127)
COLOR_LIGHT_GREY = pygame.Color(200, 200, 200)
COLOR_DARK_GREY = pygame.Color(50, 50, 50)
COLOR_ORANGE = pygame.Color(255, 127, 0)

# ==============================================================================
# -- ModuleDefines -------------------------------------------------------------
# ==============================================================================

MODULE_WORLD = 'WORLD'
MODULE_HUD = 'HUD'
MODULE_INPUT = 'INPUT'
MODULE_RENDER = 'RENDER'

# ==============================================================================
# -- ModuleManager -------------------------------------------------------------
# ==============================================================================


class ModuleManager(object):
    def __init__(self):
        self.modules = []

    def register_module(self, module):
        self.modules.append(module)

    def clear_modules(self):
        del self.modules[:]

    def tick(self, clock):
        # Update all the modules
        for module in self.modules:
            module.tick(clock)

    def render(self, display):
        display.fill((0, 0, 0))
        for module in self.modules:
            module.render(display)

    def get_module(self, name):
        for module in self.modules:
            if module.name == name:
                return module

    def start_modules(self):
        for module in self.modules:
            module.start()


# ==============================================================================
# -- ModuleRender -------------------------------------------------------------
# ==============================================================================
class ModuleRender(object):
    def __init__(self, name, antialiasing):
        self.name = name
        self.antialiasing = antialiasing

    def start(self):
        pass

    def render(self, display):
        pass

    def tick(self, clock):

        text_antialiasing = ''
        if self.antialiasing:
            text_antialiasing = 'ON'
        else:
            text_antialiasing = 'OFF'

        module_info_text = [
            'Anti-aliasing:  % 3s' % text_antialiasing,
        ]
        module_hud = module_manager.get_module(MODULE_HUD)
        module_hud.add_info(self.name, module_info_text)

    def drawLineList(self, surface, color, closed, list_lines, width):
        for line in lines:
            if not self.antialiasing:
                self.drawLine(surface, color, closed, line, width)
            else:
                self.drawLineAA(surface, color, closed, line, width)

    def drawLine(self, surface, color, closed, line, width):
        if not self.antialiasing:
            self._drawLine(surface, color, closed, line, width)
        else:
            self._drawLineAA(surface, color, closed, line, width)

    def _drawLine(self, surface, color, closed, line, width):
        pygame.draw.lines(surface, color, closed, line, width)

    def _drawLineAA(self, surface, color, closed, line, width):
        p0 = line[0]
        p1 = line[1]

        center_line_x = (p0[0]+p1[0])/2
        center_line_y = (p0[1]+p1[1])/2
        center_line = [center_line_x, center_line_y]

        length = 10  # Line size
        half_length = length / 2.

        thickness = 2
        half_thickness = thickness / 2.

        angle = math.atan2(p0[1] - p1[1], p0[0] - p1[0])
        sin_angle = math.sin(angle)
        cos_angle = math.cos(angle)

        half_length_cos_angle = (half_length) * cos_angle
        half_length_sin_angle = (half_length) * sin_angle
        half_thickness_cos_angle = (half_thickness) * cos_angle
        half_thickness_sin_angle = (half_thickness) * sin_angle

        UL = (center_line[0] + half_length_cos_angle - half_thickness_sin_angle,
              center_line[1] + half_thickness_cos_angle + half_length_sin_angle)
        UR = (center_line[0] - half_length_cos_angle - half_thickness_sin_angle,
              center_line[1] + half_thickness_cos_angle - half_length_sin_angle)
        BL = (center_line[0] + half_length_cos_angle + half_thickness_sin_angle,
              center_line[1] - half_thickness_cos_angle + half_length_sin_angle)
        BR = (center_line[0] - half_length_cos_angle + half_thickness_sin_angle,
              center_line[1] - half_thickness_cos_angle - half_length_sin_angle)

        pygame.gfxdraw.aapolygon(surface, (UL, UR, BR, BL), color)
        pygame.gfxdraw.filled_polygon(surface, (UL, UR, BR, BL), color)

    def drawCircle(self, surface, x, y, radius, color):
        if not self.antialiasing:
            self._drawCircle(surface, x, y, radius, color)
        else:
            self._drawCircleAA(surface, x, y, radius, color)

    def _drawCircle(self, surface, x, y, radius, color):
        pygame.draw.circle(surface, color, (x, y), radius)

    def _drawCircleAA(self, surface, x, y, radius, color):
        pygame.gfxdraw.aacircle(surface, x, y, radius, color)
        pygame.gfxdraw.filled_circle(surface, x, y, radius, color)

# ==============================================================================
# -- HUD -----------------------------------------------------------------------
# ==============================================================================


class ModuleHUD (object):

    def __init__(self, name, width, height):
        self.name = name
        self._init_data_params(width, height)
        self._init_hud_params()

    def start(self):
        pass

    def _init_hud_params(self):
        font = pygame.font.Font(pygame.font.get_default_font(), 20)
        fonts = [x for x in pygame.font.get_fonts() if 'mono' in x]
        default_font = 'ubuntumono'
        mono = default_font if default_font in fonts else fonts[0]
        mono = pygame.font.match_font(mono)
        self._font_mono = pygame.font.Font(mono, 14)
        self._header_font = pygame.font.SysFont('Arial', 14)

    def _init_data_params(self, height, width):
        self.dim = (height, width)
        self._show_info = True
        self._info_text = {}

    def tick(self, clock):
        if not self._show_info:
            return

    def add_info(self, module_name, info):
        self._info_text[module_name] = info

    def render(self, display):
        if self._show_info:
            info_surface = pygame.Surface((220, self.dim[1]))
            info_surface.set_alpha(100)
            display.blit(info_surface, (0, 0))
            v_offset = 4
            bar_h_offset = 100
            bar_width = 106
            i = 0
            for module_name, module_info in self._info_text.iteritems():
                surface = self._header_font.render(module_name, True, COLOR_LIGHT_GREY)
                display.blit(surface, (8 + bar_width / 2, 18 * i + v_offset))
                i += 1
                for item in module_info:
                    if v_offset + 18 > self.dim[1]:
                        break
                    if isinstance(item, list):
                        if len(item) > 1:
                            points = [(x + 8, v_offset + 8 + (1.0 - y) * 30) for x, y in enumerate(item)]
                            pygame.draw.lines(display, (255, 136, 0), False, points, 2)
                        item = None
                        v_offset += 18
                    elif isinstance(item, tuple):
                        if isinstance(item[1], bool):
                            rect = pygame.Rect((bar_h_offset, v_offset + 8), (6, 6))
                            pygame.draw.rect(display, COLOR_WHITE, rect, 0 if item[1] else 1)
                        else:
                            rect_border = pygame.Rect((bar_h_offset, v_offset + 8), (bar_width, 6))
                            pygame.draw.rect(display, COLOR_WHITE, rect_border, 1)
                            f = (item[1] - item[2]) / (item[3] - item[2])
                            if item[2] < 0.0:
                                rect = pygame.Rect((bar_h_offset + f * (bar_width - 6), v_offset + 8), (6, 6))
                            else:
                                rect = pygame.Rect((bar_h_offset, v_offset + 8), (f * bar_width, 6))
                            pygame.draw.rect(display, COLOR_WHITE, rect)
                        item = item[0]
                    if item:  # At this point has to be a str.
                        surface = self._font_mono.render(item, True, COLOR_WHITE)
                        display.blit(surface, (8, 18 * i + v_offset))
                    v_offset += 18

# ==============================================================================
# -- World ---------------------------------------------------------------------
# ==============================================================================


class ModuleWorld(object):

    def __init__(self, name, host, port, timeout):
        self.name = name
        self.host = host
        self.port = port
        self.timeout = timeout
        self.server_fps = 0
        self.server_clock = pygame.time.Clock()

    def start(self):
        try:
            client = carla.Client(self.host, self.port)
            client.set_timeout(self.timeout)
            self.world = client.get_world()
            self.town_map = self.world.get_map()
            waypoint_list = self.town_map.generate_waypoints(2.0)

        except Exception as ex:
            logging.error('Failed connecting to CARLA server')
            exit_game()

        # compute bounding boxes
        self.x_min = float('inf')
        self.y_min = float('inf')
        self.x_max = 0
        self.y_max = 0

        for waypoint in waypoint_list:
            self.x_max = max(self.x_max, waypoint.transform.location.x)
            self.x_min = min(self.x_min, waypoint.transform.location.x)

            self.y_max = max(self.y_max, waypoint.transform.location.y)
            self.y_min = min(self.y_min, waypoint.transform.location.y)

        # Retrieve data from waypoints orientation, thickness and length and do conversions into another list
        point_list = []
        for waypoint in waypoint_list:
            waypoint_length = 2.0

            # Width of road
            thickness = int(waypoint.lane_width)

            # Orientation of road
            color = COLOR_BLACK
            if waypoint.lane_id < 0:
                color = COLOR_CYAN
            else:
                color = COLOR_ORANGE

            direction = (1, 0)
            yaw = math.radians(waypoint.transform.rotation.yaw)
            waypoint_front = (direction[0] * math.cos(yaw) - direction[1] * math.sin(yaw),
                              direction[0] * math.sin(yaw) + direction[1] * math.cos(yaw))

            point_list.append(((waypoint.transform.location.x, waypoint.transform.location.y),
                               (waypoint.transform.location.x + waypoint_front[0] * waypoint_length,
                                waypoint.transform.location.y + waypoint_front[1] * waypoint_length), color, thickness))

        # Create Surface
        self.hud_module = module_manager.get_module(MODULE_HUD)
        self.surface_size = min(self.hud_module.dim[0], self.hud_module.dim[1])
        self.surface = pygame.Surface((self.surface_size, self.surface_size))

        # normalize waypoints based on surface size
        self.normalized_point_list = []
        for point in point_list:
            x_0 = ((point[0][0] - self.x_min) / float((self.x_max - self.x_min))) * self.surface_size
            y_0 = ((point[0][1] - self.y_min) / float((self.y_max - self.y_min))) * self.surface_size

            x_1 = float(point[1][0] - self.x_min) / (float((self.x_max - self.x_min))) * self.surface_size
            y_1 = float(point[1][1] - self.y_min) / (float((self.y_max - self.y_min))) * self.surface_size

            self.normalized_point_list.append(([(x_0, y_0), (x_1, y_1)], point[2], point[3]))

        # Module render
        self.render_module = module_manager.get_module(MODULE_RENDER)

        self.actors = self.world.get_actors()

        self.select_to_hero_mode()
        self.hero_mode = False

        weak_self = weakref.ref(self)
        self.world.on_tick(lambda timestamp: ModuleWorld.on_world_tick(weak_self, timestamp))

    def tick(self, clock):

        hero_mode_text = ''
        if self.hero_mode:
            hero_mode_text = 'ON'
        else:
            hero_mode_text = 'OFF'

        module_info_text = [
            'Server:  % 16d FPS' % self.server_fps,
            'Client:  % 16d FPS' % clock.get_fps(),
            'Hero Mode:               % 3s' % hero_mode_text
        ]
        module_hud = module_manager.get_module(MODULE_HUD)
        module_hud.add_info(self.name, module_info_text)

    @staticmethod
    def on_world_tick(weak_self, timestamp):
        self = weak_self()
        if not self:
            return

        self.server_clock.tick()
        self.server_fps = self.server_clock.get_fps()

    def render_map(self, display):
        for point in self.normalized_point_list:
            self.render_module.drawLine(self.surface, point[1], False, point[0], point[2])

    def render_actors(self, display, list_actors, color, radius, width):
        for actor in list_actors:
            actor_location = actor.get_location()
            x = int((actor_location.x - self.x_min) / float(self.x_max - self.x_min) * self.surface_size)
            y = int((actor_location.y - self.y_min) / float(self.y_max - self.y_min) * self.surface_size)

            if 'traffic_light' in actor.type_id:
                if actor.state == carla.libcarla.TrafficLightState.Green:
                    color = COLOR_GREEN
                elif actor.state == carla.libcarla.TrafficLightState.Yellow:
                    color = COLOR_YELLOW
                elif actor.state == carla.libcarla.TrafficLightState.Red:
                    color = COLOR_RED
                else:
                    color = COLOR_BLACK

            self.render_module.drawCircle(self.surface, x, y, radius, color)

    def render(self, display):
        self.surface.fill(COLOR_DARK_GREY)
        self.render_map(display)

        vehicles = [actor for actor in self.actors if 'vehicle' in actor.type_id]
        traffic_lights = [actor for actor in self.actors if 'traffic_light' in actor.type_id]
        speed_limits = [actor for actor in self.actors if 'speed_limit' in actor.type_id]

        if self.hero_mode:
            draw_hero_actor = [vehicle for vehicle in vehicles if vehicle.id == self.hero_actor.id]
            vehicles = [vehicle for vehicle in vehicles
                        if abs(vehicle.get_location().x - self.hero_actor.get_location().x <= self.filter_radius)
                        and abs(vehicle.get_location().y - self.hero_actor.get_location().y) <= self.filter_radius
                        and vehicle.id != self.hero_actor.id]

            self.render_actors(display, draw_hero_actor, COLOR_ORANGE, 5, 5)

            traffic_lights = [traffic_light for traffic_light in traffic_lights
                              if abs(traffic_light.get_location().x - self.hero_actor.get_location().x <= self.filter_radius)
                              and abs(traffic_light.get_location().y - self.hero_actor.get_location().y) <= self.filter_radius]

            speed_limits = [speed_limit for speed_limit in speed_limits
                            if (abs(speed_limit.get_location().x - self.hero_actor.get_location().x) <= self.filter_radius)
                            and abs(speed_limit.get_location().y - self.hero_actor.get_location().y) <= self.filter_radius]

        self.render_actors(display, vehicles, COLOR_MAGENTA, 5, 5)
        self.render_actors(display, traffic_lights, COLOR_BLACK, 3, 3)
        self.render_actors(display, speed_limits, COLOR_BLUE, 3, 3)

        module_input = module_manager.get_module(MODULE_INPUT)
        result_surface = pygame.transform.smoothscale(self.surface,
                                                      (int(self.surface_size * module_input.wheel_offset[0]),
                                                       int(self.surface_size * module_input.wheel_offset[1])))

        display.blit(result_surface, (module_input.mouse_offset[0], module_input.mouse_offset[1]))

    def select_to_hero_mode(self):
        self.filter_radius = 50
        self.hero_actor = [actor for actor in self.actors if 'vehicle' in actor.type_id][1]

# ==============================================================================
# -- Input -----------------------------------------------------------
# ==============================================================================


class ModuleInput(object):
    def __init__(self, name):
        self.name = name
        self.mouse_pos = (0, 0)
        self.mouse_offset = [0.0, 0.0]
        self.wheel_offset = [1.0, 1.0]

    def start(self):
        pass

    def render(self, display):
        pass

    def tick(self, clock):
        self.parse_input()

    def _parse_events(self):
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                exit_game()
            elif event.type == pygame.KEYUP:
                if event.key == K_ESCAPE:
                    exit_game()
                if event.key == K_a:
                    module_render = module_manager.get_module(MODULE_RENDER)
                    module_render.antialiasing = not module_render.antialiasing
                if event.key == K_h:
                    module_world = module_manager.get_module(MODULE_WORLD)
                    module_world.hero_mode = not module_world.hero_mode
            elif event.type == pygame.MOUSEBUTTONDOWN:
                self.mouse_pos = pygame.mouse.get_pos()
                if event.button == 4:
                    self.wheel_offset[0] += 0.1
                    self.wheel_offset[1] += 0.1

                if event.button == 5:
                    self.wheel_offset[0] -= 0.1
                    self.wheel_offset[1] -= 0.1
                    if self.wheel_offset[0] <= 0.1:
                        self.wheel_offset[0] = 0.1
                    if self.wheel_offset[1] <= 0.1:
                        self.wheel_offset[1] = 0.1

    def _parse_keys(self):
        keys = pygame.key.get_pressed()
        # if keys[pygame.K_LEFT]:
        # Do something

    def _parse_mouse(self):
        if pygame.mouse.get_pressed()[0]:
            x, y = pygame.mouse.get_pos()
            self.mouse_offset[0] = self.mouse_offset[0] + x - self.mouse_pos[0]
            self.mouse_offset[1] += y - self.mouse_pos[1]
            self.mouse_pos = (x, y)

    def parse_input(self):
        self._parse_events()
        self._parse_keys()
        self._parse_mouse()

# ==============================================================================
# -- Game Loop ---------------------------------------------------------------
# ==============================================================================


module_manager = ModuleManager()


def game_loop(args):
    # Init Pygame
    pygame.init()
    display = pygame.display.set_mode(
        (args.width, args.height),
        pygame.HWSURFACE | pygame.DOUBLEBUF)
    pygame.display.set_caption(args.description)

    # Init modules
    input_module = ModuleInput(MODULE_INPUT)
    hud_module = ModuleHUD(MODULE_HUD, args.width, args.height)
    world_module = ModuleWorld(MODULE_WORLD, args.host, args.port, 2.0)
    render_module = ModuleRender(MODULE_RENDER, bool(args.antialiasing == 'True'))

    # Register Modules
    module_manager.register_module(input_module)
    module_manager.register_module(render_module)
    module_manager.register_module(world_module)
    module_manager.register_module(hud_module)

    module_manager.start_modules()

    clock = pygame.time.Clock()
    while True:
        clock.tick_busy_loop(60)

        module_manager.tick(clock)
        module_manager.render(display)

        pygame.display.flip()


def exit_game():
    module_manager.clear_modules()
    pygame.quit()
    sys.exit()

# ==============================================================================
# -- Main --------------------------------------------------------------------
# ==============================================================================


def main():
    # Parse arguments
    argparser = argparse.ArgumentParser(
        description='CARLA No Rendering Mode Visualizer')
    argparser.add_argument(
        '-v', '--verbose',
        action='store_true',
        dest='debug',
        help='print debug information')
    argparser.add_argument(
        '--host',
        metavar='H',
        default='127.0.0.1',
        help='IP of the host server (default: 127.0.0.1)'
    )
    argparser.add_argument(
        '-p', '--port',
        metavar='P',
        default=2000,
        type=int,
        help='TCP port to listen to (default: 2000)')
    argparser.add_argument(
        '--res',
        metavar='WIDTHxHEIGHT',
        default='1280x720',
        help='window resolution (default: 1280x720)')

    argparser.add_argument(
        '--antialiasing',
        metavar='antialiasing',
        default=True,
        help='antialiasing (default: True)')
    args = argparser.parse_args()
    args.description = argparser.description
    args.width, args.height = [int(x) for x in args.res.split('x')]

    log_level = logging.DEBUG if args.debug else logging.INFO
    logging.basicConfig(format='%(levelname)s: %(message)s', level=log_level)

    logging.info('listening to server %s:%s', args.host, args.port)
    print(__doc__)

    try:
        game_loop(args)
    except KeyboardInterrupt:
        print('\nCancelled by user. Bye!')


if __name__ == '__main__':
    main()
